## Project Overview

Dasi is a powerful desktop copilot application that provides inline LLM support through a global hotkey (Ctrl+Alt+Shift+I by default). The app integrates with multiple AI model providers including Google Gemini, OpenAI, Anthropic, Groq, Ollama, Deepseek, Together AI, OpenRouter, and custom OpenAI-compatible endpoints. It features a modern, borderless interface that appears near the cursor and operates in two primary modes: Chat Mode for interactive conversations and Compose Mode for direct content generation and insertion.

## Architecture

- **Main Components**:
  - `main.py`: Entry point and application controller
  - `llm_handler.py`: Manages interactions with various LLM providers
  - `hotkey_listener.py`: Handles global hotkey detection
  - `ui/`: Contains all UI components and settings
  - `backend/`: Backend services and utilities
  - `ui/assets/`: Contains stylesheets, themes, and icons for the UI

## Theme Colors

- **Primary Theme Color**: #e67e22 (Orange)
- **Primary Hover**: #d35400 (Darker orange)
- **Primary Pressed**: #a04000 (Very dark orange)
- **Danger/Alert Color**: #dc2626 (Red)
- **Background Colors**:
  - Main background: #1a1a1a (Very dark gray)
  - Card/widget background: #222222 (Dark gray)
  - Input field background: #2a2a2a (Medium dark gray)
- **Border Colors**:
  - Default border: #333333 (Medium gray)
  - Hover border: #444444 (Light gray)
  - Focus border: #e67e22 (Orange - same as primary)
- **Text Colors**:
  - Primary text: #e0e0e0 (Light gray/off-white)
  - Secondary text: #aaaaaa (Medium gray)
  - Disabled text: #666666 (Dark gray)

## Code Style Guidelines

- **Python Conventions**:
  - Use PEP 8 style guidelines
  - Class names use CamelCase
  - Function and variable names use snake_case
  - Constants use UPPER_SNAKE_CASE
  - Maximum line length of 100 characters

- **UI Components**:
  - PyQt6 is used for all UI elements
  - UI components are organized in a modular fashion
  - Use SectionFrame for consistent section styling across all tabs
  - Custom styling is applied via centralized stylesheets
  - Follow the existing pattern of separating UI setup from logic
  - Use CSS-like class properties instead of inline styles
  - Leverage the theme system for consistent styling
  - Maintain consistent spacing (12px between sections, 16px padding)
  - Set right content margin to 8px to allow space between content and scrollbar
  - Use transparent backgrounds for container widgets with the "transparent-container" class
  - Implement custom ComboBoxStyle for dropdown arrows for consistent styling

- **Error Handling**:
  - Use try/except blocks for operations that might fail
  - Log errors with appropriate severity levels
  - Provide user-friendly error messages in the UI

## Key Features

### Prompt Chunks System
- Prompt chunks are predefined templates that can be invoked using `@` mentions
- Each chunk has a title (used for @mentions) and content (the template text)
- Titles must be alphanumeric with underscores, no spaces, lowercase
- Implementation is in `src/ui/settings/prompt_chunks_tab.py`

### LLM Integration
- Uses LangChain for unified interface to multiple LLM providers
- Supports system prompts, custom instructions, and temperature settings
- Maintains chat history with configurable limits
- Implementation is in `src/llm_handler.py`

### Settings Management
- Settings are stored in JSON format at `~/.config/dasi/settings.json`
- Follows XDG specification for configuration storage
- Includes API keys, model configurations, and general preferences
- Implementation is in `src/ui/settings/settings_manager.py`

### Modern UI System
- Uses a combination of QDarkTheme and custom stylesheets for a professional look
- Implements a card-based design with proper spacing and visual hierarchy
- Provides consistent styling across all components through a centralized stylesheet
- Uses icons for better visual recognition and user experience
- Supports both light and dark themes with proper color contrast
- Implements scrollable content areas with transparent scrollbars
- Uses SectionFrame for consistent section headers with titles and descriptions

## Form Controls Styling

- **Checkboxes**:
  - Rely on the global stylesheet for checkbox styling rather than inline styles
  - Use `checkmark.png` or `checkmark.svg` from the icons directory for the checked state
  - Apply hover effects for better user feedback
  - Use proper spacing (8px) and consistent styling

- **Dropdown Menus**:
  - Use the ComboBoxStyle class for consistent dropdown arrow styling in orange (#e67e22)
  - Implement proper padding (10px 12px) and border radius (6px)
  - Use consistent colors: #222222 background with #333333 borders
  - Use orange (#e67e22) borders for hover and focus states
  - Implement orange highlighting for selected items

- **Spinboxes**:
  - Style spinboxes consistently with padding (10px 12px)
  - Style up/down buttons with proper colors and hover effects
  - Use border radius (6px) matching other form controls

- **Buttons**:
  - Primary actions: Use "primary" class (orange styling - #e67e22)
  - Danger actions: Use "danger" class (red styling - #dc2626) 
  - Secondary actions: Use default styling (gray with orange hover borders)
  - Apply consistent button spacing (8px between buttons)
  - Follow appropriate button ordering conventions (Cancel/Reset, then Save/Apply)

## Best Practices

1. **Configuration Management**:
   - Always use the Settings class for accessing configuration
   - Emit appropriate signals when settings change
   - Follow the pattern of providing sensible defaults

2. **UI Development**:
   - Create reusable components when possible
   - Maintain consistent styling across the application
   - Use the centralized stylesheet in `ui/assets/style.qss` for styling
   - Apply CSS-like classes to widgets using the `setProperty` method
   - Use the theme system in `ui/assets/theme.py` for consistent theming
   - Follow the card-based UI pattern with SectionFrame for content organization
   - Use consistent spacing (12px between sections, 16px margins)
   - Use transparent backgrounds for container widgets
   - Implement scrollable content areas with transparent scrollbars
   - Ensure all form controls follow the established styling patterns
   - Show/hide action buttons based on whether there are unsaved changes
   - Support keyboard navigation with proper tab order and keyboard shortcuts

3. **LLM Integration**:
   - Use the LLMHandler class for all LLM interactions
   - Follow the established pattern for adding new model providers
   - Properly handle API keys and authentication

4. **Error Handling and Logging**:
   - Use the established logging system
   - Log appropriate information at the correct severity level
   - Handle exceptions gracefully with user-friendly messages

5. **Hotkey Management**:
   - Use the HotkeyListener class for global hotkey functionality
   - Follow platform-specific patterns for key detection

6. **Prompt Chunks**:
   - Follow the established pattern for creating and managing prompt chunks
   - Ensure titles are properly formatted (alphanumeric with underscores)
   - Maintain backward compatibility with existing chunk formats

## Common Patterns

1. **Settings Access**:
   ```python
   from ui.settings import Settings
   
   settings = Settings()
   value = settings.get('section', 'key', default='default_value')
   ```

2. **LLM Interaction**:
   ```python
   from llm_handler import LLMHandler
   
   llm_handler = LLMHandler()
   response = await llm_handler.generate_response(prompt, session_id)
   ```

3. **UI Component Creation**:
   ```python
   from PyQt6.QtWidgets import QWidget, QVBoxLayout
   from .general_tab import SectionFrame
   
   class CustomComponent(QWidget):
       def __init__(self, parent=None):
           super().__init__(parent)
           self.setup_ui()
           
       def setup_ui(self):
           layout = QVBoxLayout(self)
           layout.setSpacing(12)
           layout.setContentsMargins(16, 16, 0, 16)
           
           # Create a section with title and description
           section = SectionFrame(
               "Section Title",
               "Section description providing context for the contained settings."
           )
           
           # Add content to the section
           content_container = QWidget()
           content_container.setProperty("class", "transparent-container")
           content_layout = QVBoxLayout(content_container)
           content_layout.setContentsMargins(0, 0, 0, 0)
           content_layout.setSpacing(8)
           
           # Add the content container to the section
           section.layout.addWidget(content_container)
           
           # Add the section to the main layout
           layout.addWidget(section)
   ```

4. **Applying Styles to Widgets**:
   ```python
   # Use CSS-like classes instead of inline styles
   my_button.setProperty("class", "primary")
   
   # For dynamic style changes, refresh the style
   my_button.style().unpolish(my_button)
   my_button.style().polish(my_button)
   ```

5. **Creating Card-Based Layouts**:
   ```python
   # Import SectionFrame for consistent card styling
   from .general_tab import SectionFrame
   
   # Create a section with title and description
   card = SectionFrame(
       "Card Title",
       "Card description with additional context."
   )
   
   # Add content to the card
   content_widget = QWidget()
   content_widget.setProperty("class", "transparent-container")
   content_layout = QVBoxLayout(content_widget)
   content_layout.setContentsMargins(0, 0, 0, 0)
   content_layout.setSpacing(8)
   
   # Add widgets to content_layout
   
   # Add the content widget to the card
   card.layout.addWidget(content_widget)
   ```

6. **ComboBox with Custom Arrow Style**:
   ```python
   # Create custom style class for drawing combobox arrows
   class ComboBoxStyle(QProxyStyle):
       def __init__(self, style=None):
           super().__init__(style)
           
       def drawPrimitive(self, element, option, painter, widget=None):
           if element == QStyle.PrimitiveElement.PE_IndicatorArrowDown and isinstance(widget, QComboBox):
               # Draw a custom arrow
               rect = option.rect
               painter.save()
               painter.setPen(Qt.GlobalColor.white)
               painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, "▼")
               painter.restore()
               return
           super().drawPrimitive(element, option, painter, widget)
   
   # Create and style the combobox
   combo_box = QComboBox()
   combo_box.setStyle(ComboBoxStyle())
   ```

7. **Applying the Theme**:
   ```python
   from ui.assets import apply_theme
   
   # Apply the theme to the application
   apply_theme(app, "dark")  # Options: "dark", "light", "auto"
   ```

8. **Handling Unsaved Changes**:
   ```python
   # Check for unsaved changes
   def check_for_changes(self):
       current = self.get_current_values()
       self.has_unsaved_changes = current != self.original_values
       self.update_button_visibility()
       
   # Update button visibility based on changes
   def update_button_visibility(self):
       self.button_container.setVisible(self.has_unsaved_changes)
   
   # Connect change signals
   self.input_field.textChanged.connect(self._on_any_change)
   
   # Handle change events
   def _on_any_change(self):
       self.check_for_changes()
   ```

9. **Prompt Chunk Usage**:
   ```python
   # Format for accessing prompt chunks in text
   text_with_chunk = "Let me help you with this @chunk_name problem"
   ```

**After installing a package check if its present in requirements.txt**
- To run the app activate venv and run python `src/main.py`